#include <iostream>
#include <string>
#include <fstream>
using namespace std;

//глобальные переменные (доступны всем функциям программы)

char stack[30]{}; //символьный массив
int tos = 0;	  //переменная, которая отмечает вершину стека
int c = 0;		  //счетчик
string s1;		  //выходная строка

void push(char element) // Функция push() для добавления элементов в стек
{
	if (tos >= 30); //если элементов более 30 то ничего не делаем
	else			//иначе:
	{
		stack[tos] = element; //заносим символ на вершину стека
		tos++;				  //увеличиваем вершину стека и счетчик на 1
		c++;
	}
}

void pop(void) // Функция pop() для удаления элементов из стека
{
	tos--; //уменьшаем вершину стека
	if (tos < 0); //если элементов больше не осталось то ничего не делаем
	else
	{
		if (stack[tos] != '\0' && stack[tos] != '(') //если элемент содержит не символ конца строки или открывающую скобку
		{
			s1 += stack[tos]; //копируем в строку крайний элемент
			stack[tos] = '\0'; //на его место записываем символ конца строки
		}
	}
}




int main()
{
	setlocale(LC_ALL, "ru");

	//задаем размер массива и инициализируем символьный массив
	const int SIZE = 30;
	char a[SIZE]{};

	int pr = 0;

	//ввод и вывод будет происходить через файлы
	ifstream flot("input.txt");
	ofstream out("exit.txt");

	//проверка на открытие файла
	if (!flot)
	{
		cout << "Файл не работает!"; //если файл не открылся выводим в консоль сообщение об ошибке
	}
	else //если файл успешно открылся то читаем строку из файла и записываем ее в символьный массив
	{
		flot.getline(a, SIZE);
	}

	//релизация алгоритма Дейкстры:

	for (int i = 0; i < SIZE; i++) //проходим по массиву
	{
		if ((a[i] == '+' || a[i] == '-' || a[i] == '*' || a[i] == '/' || a[i] == '(' || a[i] == '^') && stack[0] == '\0')
		{
			push(a[i]); //Если символ операция и стек пуст, то он проталкивается в стек.

		}

		else
			if ((a[i] == '+' || a[i] == '-') && stack[0] != '\0')
			{
				/*
				Если символ операция и стек не пуст, а приоритет
				символа операции меньше, чем у символа операции
				вершины стека, то прочитанный символ проталкивается и
				стек.
				*/
				if (stack[0] == '/' || stack[0] == '*' || stack[0] == '^')
				{
					push(a[i]);
				}
				else
				{
					push(a[i]);
				}
			}

			else
				if ((a[i] == '*' || a[i] == '/') && stack[0] != '\0')
				{
					/*
					Если символ операция и стек не пуст, а приоритет
					символа вершины стека, меньше приоритета входного
					символа,
					*/
					if (stack[0] == '+' || stack[0] == '-' || stack[0] == '(')
					{
						for (int i = 0; i < c; i++) // то из стека в выходную строку выталкиваются																
						{							//все символы операций с меньшим или равным
							pop();					//приоритету входного символа,
						}
						push(a[i]);
					}
					else					//после чего входной									
					{						//символ операции заносится в стек.
						push(a[i]);
					}
				}

				else
					if ((a[i] == '^') && stack[0] != '\0') //то же условие что и в предыдущем else if, приоритет символа '^' наименьший
					{
						for (int i = 0; i < c; i++)
						{
							if (stack[i] != '\0')
							{
								pop();
							}

							else
							{
								break;
							}

						}
						push(a[i]);
					}

					else if (a[i] == '(')
					{
						push(a[i]);	// Если входной символ левая открывающая скобка, то
									//она проталкивается в стек
					}

					else if ((a[i]) == ')')
					{
						//Если входной символ правая закрывающая скобка, 

						for (int i = 0; i < c; i++) //то она выталкивает из стека в выходную строку все символы
						{
							if (stack[i] != '(') //до левой открывающей скобки
							{
								pop();
							}
							else
							{
								stack[i] = '\0';
								break;
							}
							//сами скобки уничтожаются и в выходную строку не попадают.
						}
					}

		/*Если входной символ - маркер конца строки, то из
		стека в выходную строку выталкиваются все символы.*/
					else if (a[i] == '\0') {
						break;
					}

					else //Результат выходной строки. Конец алгоритма.
					{
						s1 += a[i];
					}
	}

	cout << s1 << endl; //вывод выходной строки на консоль
	out << s1 << endl;	//вывод выходной строки в файл

	//закрываем файлы для ввода и вывода
	flot.close();
	out.close();

	return 0;
}