
#include "Service.h"  //подключаем файл заголовка

Service::Service(void) //при вызове конструктора список очищается
{
	serv.clear();
}

bool Service::add_service(string procent_count) //добавление элемента
//принимает строку, которую нужно добавить
//возвращает значение true/false, которое зависит от правильности выполнения операции
{
	bool result = true; //переменная для проверки правильности выполнения операции

	serv.push_back(procent_count); //добавление переданного элемента в конец списка
	return result;
}

int Service::string_to_time(string time, bool h_or_m) //функция перевода строки в формат времени
//принимает строку, которую нужно перевести, а также булевую переменную h_or_m
//если эта переменная имеет значение true, то функция возвращает часы, иначе - минуты
{
	string t = time; //копируем строку в новую переменную чтоб случайно не изменить
	string tmp;		 //временная строковая переменная для перевода string в int
	int res = 0;	 // переменная для записи результата

	if (h_or_m == true)	//если нужно получить часы
	{
		for (int i = 0; i < 2; i++) //читаем первые два символа строки
		{
			tmp += t[i]; //копируем их во временную переменную
		}
	}
	else	//если нужны минуты
	{
		for (int i = 3; i < 5; i++)	//читаем последние два символа строки (после ':')
		{
			tmp += t[i]; //копируем их во временную переменную
		}
	}
	res = stoi(tmp); //перевод strind в int
	return res;		//возвращаем полученное значение
}

bool Service::time_check(string t_begin, string t_end, string t_moment) //проверка времени
//принимает три строки: границы временного промежутка и время указанное в заказе
//сравнивает их и возвращает true/false
//если время заказа попадает в промежуток - true, иначе - false
{
	//временные переменные для записи времени, отдельно часы и минуты
	int h1, h2, h3;
	int m1, m2, m3;

	//переводим строки в часы и минуты
	h1 = string_to_time(t_begin, true);
	h2 = string_to_time(t_end, true);
	h3 = string_to_time(t_moment, true);

	m1 = string_to_time(t_begin, false);
	m2 = string_to_time(t_end, false);
	m3 = string_to_time(t_moment, false);

	if (h1 > h3 || h2 < h3) // если час заказа не попадает в промежуток то вовращаем false
	{
		return false;
	}
	if (h1 < h3 || h2 > h3) //если час заказа попадает в промежуток, то вовращаем true
	{
		return true;
	}

	if (h1 == h3)	//если час заказа равен нижней границе промежутка, сравниваем минуты
	{
		if (m1 <= m3) //если кол-во минут во времени заказа больше, то возвращаем true
		{
			return true;
		}
		else return false; //иначе - false
	}

	if (h3 == h2)	//если час заказа равен верхней границе промежутка, сравниваем минуты
	{
		if (m3 <= m2)	//если минут во времени заказа меньше, то возвращаем true
		{
			return true;
		}
		else return false; //иначе - false
	}
}

//функция поиска клиентов по указанной услуге и временному промежутку
list<string> Service::get_client_by_serv_order(string serv_name, string t1, string t2, list<string> orders, list<string> clients)
//принимает 3 строки и 2 списка
//строки: наименование услуги и границы временного промежутка
//списки: список заказов из класса Order и список клиентов из класса Client
//возвращает список клиентов, сделавших заказ на указанную услугу в указанный промежуток времени
{	
	
	
	list<string> Result;	//новый список для вывода результата
	int index = 0;	//счетчик, для работы с булевыми массивами

	//два булевых динамических массива, кол-во элементов равно кол-ву элементов соответствующего списка 
	bool* serv_temp = new bool[serv.size()+1];
	bool* time_tmp = new bool[orders.size()+1];

	for (int i = 0; i < serv.size(); i++) //по умолчанию все элементы массива должны иметь значение false
	{
		serv_temp[i] = false;
		time_tmp[i] = false;
	}

	/*
	два булевых массива используются в качестве флаговых массивов 
	в последующей итерации мы ищем в списке услуг те, наименование
	которых совпадают с переданным в функцию 
	при нахождении такого элемента, в флаговом массиве элемент с таким же индексом принимает значение true
	*/

	for (auto j = serv.begin(); j != serv.end(); j++)
	{
		if (*j == serv_name)
		{
			serv_temp[index] = true;
		}
		index++;
	}
	index = 0; //обнуляем счетчик

	//цикл работает аналогично предыдущему, только итерация списка заказов и проверка на вхождение 
	//времени заказа(элемента списка) в указанный промежуток времени
	for (auto i = orders.begin(); i != orders.end(); i++)
	{
		bool check = time_check(t1, t2, *i); 
		if (check == true) 
		{
			time_tmp[index] = true;
		}
		index++;
	}
	index = 0;
	
	//теперь проходим по списку клиентов
	for (auto i = clients.begin(); i != clients.end(); i++)
	{
		//смортрим одновременно два флаговых массива
		//если элементы с одинаковым индексом в них одновременно имеют значение true
		if (serv_temp[index] == true && time_tmp[index] == true)
		{
			Result.push_back(*i); //то добавляем этот элемент из списка клиентов в результирующий список
		}
		index++;
	}
	
	return Result; //возвращаем результирующий список
}
